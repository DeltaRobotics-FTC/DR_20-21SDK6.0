Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/customOdometryTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\n\n//import org.firstinspires.ftc.teamcode.OdometryGlobalCoordinatePosition;\n\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\n\n@TeleOp(name = \"customOdometryTest\")\npublic class customOdometryTest extends LinearOpMode\n{\n\n    //encoder counts per in of movement (counts per rotation / pi*r^2\n    final double COUNTS_PER_INCH = 1312.54037886341;\n\n    //OdometryGlobalCoordinatePosition is the thread\n//globalPositionThread is a variable that will hold the thread with specific info like the names of the encoders\n    OdometryGlobalCoordinatePosition globalPositionUpdate;\n\n    @Override\n    public void runOpMode() throws InterruptedException\n    {\n\n//call hardware map\n        RobotHardware robot = new RobotHardware(hardwareMap);\n\n        robot.motorRF.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        robot.motorLF.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        robot.motorRB.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        robot.motorLB.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        telemetry.addData(\"Status\", \"Init Complete\");\n        telemetry.update();\n        waitForStart();\n\n//fills the thread variable with the thread with encoder names how many ticks per in and the delay\n        globalPositionUpdate = new OdometryGlobalCoordinatePosition(robot.verticalLeft, robot.verticalRight, robot.horizontal, COUNTS_PER_INCH, 75);\n        Thread positionThread = new Thread(globalPositionUpdate);\n        positionThread.start();\n\n        goToPosition(100, 0, 1, 0, .5, 1);\n        goToPosition(0, 0, 1, 0, .5, 1);\n\n        while(opModeIsActive())\n        {\n\n            goToPosition(50, 0, 1, 0, .5, 1);\n\n            goToPosition(50, 50, 1, 0, .5, 1);\n\n            goToPosition(0, 0, 1, 0, .5, 1);\n\n//Display Global (x, y, theta) coordinates\n            telemetry.addData(\"X Position\", globalPositionUpdate.returnXCoordinate() / COUNTS_PER_INCH);\n            telemetry.addData(\"Y Position\", globalPositionUpdate.returnYCoordinate() / COUNTS_PER_INCH);\n            telemetry.addData(\"Orientation (Degrees)\", globalPositionUpdate.returnOrientation());\n\n//Display encoder values\n            telemetry.addData(\"Vertical left encoder position\", robot.verticalLeft.getCurrentPosition());\n            telemetry.addData(\"Vertical right encoder position\", robot.verticalRight.getCurrentPosition());\n            telemetry.addData(\"horizontal encoder position\", robot.horizontal.getCurrentPosition());\n\n            telemetry.addData(\"motorRF power\", robot.motorRF.getPower());\n            telemetry.addData(\"motorRB power\", robot.motorRB.getPower());\n            telemetry.addData(\"motorLF power\", robot.motorLF.getPower());\n            telemetry.addData(\"motorLB power\", robot.motorLB.getPower());\n\n            telemetry.addData(\"Thread Active\", positionThread.isAlive());\n            telemetry.update();\n        }\n\n//Stop the thread\n        globalPositionUpdate.stop();\n\n    }\n\n    public void goToPosition(double targetXPosition, double targetYPosition, double robotPower, double robotOrientation, double allowableDistanceError, double allowableOrientationError)\n    {\n        RobotHardware robot = new RobotHardware(hardwareMap);\n\n        boolean runLoop = true;\n\n        targetXPosition = targetXPosition * COUNTS_PER_INCH;\n        targetYPosition = targetYPosition * COUNTS_PER_INCH;\n        allowableDistanceError = allowableDistanceError * COUNTS_PER_INCH;\n\n        double distanceToXTarget = targetXPosition - globalPositionUpdate.returnXCoordinate();\n        double distanceToYTarget = targetYPosition - globalPositionUpdate.returnYCoordinate();\n\n        while(opModeIsActive() &&  runLoop)\n        {\n            double distance = Math.hypot(distanceToXTarget, distanceToYTarget);\n\n            double pivotCorectionAngle = robotOrientation - globalPositionUpdate.returnOrientation();\n\n            if (distance > allowableDistanceError || pivotCorectionAngle > allowableOrientationError)\n            {\n                runLoop = true;\n            }\n\n            else\n            {\n                runLoop = false;\n            }\n\n\n            distanceToXTarget = targetXPosition - globalPositionUpdate.returnXCoordinate();\n            distanceToYTarget = targetYPosition - globalPositionUpdate.returnYCoordinate();\n\n            double robotMovementAngle = Math.toDegrees(Math.atan2(distanceToXTarget, distanceToYTarget));\n\n            double robotMovementXComponent = calculateX(robotMovementAngle, robotPower);\n            double robotMovementYComponent = calculateY(robotMovementAngle, robotPower);\n\n            double pivotCorectionAngl = robotOrientation - globalPositionUpdate.returnOrientation();\n            double pivotCorectionPower = pivotCorectionAngle / 180;\n\n            //slows down as it nears the target (average of the turn and distance error)\n            double slowDown;\n            double distanceSlowDown;\n            double angleSlowDown;\n\n            if (Math.abs(distance / COUNTS_PER_INCH) <= 3)\n            {\n                distanceSlowDown = Math.abs(distance / 3);\n            }\n\n            else\n            {\n                distanceSlowDown = 1;\n            }\n\n            if (Math.abs(robotOrientation) <= 5 && Math.abs(distance / COUNTS_PER_INCH) <= 3)\n            {\n                angleSlowDown = Math.abs(robotOrientation / 5);\n            }\n\n            else\n            {\n                angleSlowDown = 1;\n            }\n\n            slowDown = (angleSlowDown + distanceSlowDown) / 2;\n\n\n\n            //sets the power of the motors\n            double LFpower = (robotMovementXComponent + robotMovementYComponent + pivotCorectionPower) * slowDown * robotPower;\n            double LBpower = (robotMovementXComponent - robotMovementYComponent + pivotCorectionPower) * slowDown * robotPower;\n            double RFpower = (robotMovementXComponent - robotMovementYComponent - pivotCorectionPower) * slowDown * robotPower;\n            double RBpower = (robotMovementXComponent + robotMovementYComponent - pivotCorectionPower) * slowDown * robotPower;\n\n//if statement reduces/increases motor power accordingly if a motor has more than a power of 1 or less than a power of -1\n//that way all the motors remain proportional but at the highest speed possible forward or reverse\n//if you move slowly there is nothing to reduce and it will still go slowly\n\n            double motorPowerRatio = 1;\n\n            if (LFpower >= 1 && LFpower >= LBpower && LFpower >= RFpower && LFpower >= RBpower)\n            {\n                motorPowerRatio = 1 / LFpower;\n            } else if (LBpower >= 1 && LBpower >= LFpower && LBpower >= RFpower && LBpower >= RBpower)\n            {\n                motorPowerRatio = 1 / LBpower;\n            } else if (RFpower >= 1 && RFpower >= LFpower && RFpower >= LBpower && RFpower >= RBpower)\n            {\n                motorPowerRatio = 1 / RFpower;\n            } else if (RBpower >= 1 && RBpower >= LFpower && RBpower >= RFpower && RBpower >= LBpower)\n            {\n                motorPowerRatio = 1 / RBpower;\n            } else if (LFpower <= -1 && LFpower <= LBpower && LFpower <= RFpower && LFpower <= RBpower)\n            {\n                motorPowerRatio = -1 / LFpower;\n            } else if (LBpower <= -1 && LBpower <= LFpower && LBpower <= RFpower && LBpower <= RBpower)\n            {\n                motorPowerRatio = -1 / LBpower;\n            } else if (RFpower <= -1 && RFpower <= LFpower && RFpower <= LBpower && RFpower <= RBpower)\n            {\n                motorPowerRatio = -1 / RFpower;\n            } else if (RBpower <= -1 && RBpower <= LFpower && RBpower <= RFpower && RBpower <= LBpower)\n            {\n                motorPowerRatio = -1 / RBpower;\n            }\n\n\n\n//robot power is your speed multiplier\n\n            robot.motorRF.setPower(RFpower * motorPowerRatio);\n            robot.motorRB.setPower(RBpower * motorPowerRatio);\n            robot.motorLB.setPower(LBpower * motorPowerRatio);\n            robot.motorLF.setPower(LFpower * motorPowerRatio);\n\n            telemetry.addData(\"X Position\", globalPositionUpdate.returnXCoordinate() / COUNTS_PER_INCH);\n            telemetry.addData(\"Y Position\", globalPositionUpdate.returnYCoordinate() / COUNTS_PER_INCH);\n            telemetry.addData(\"Orientation (Degrees)\", globalPositionUpdate.returnOrientation());\n\n            telemetry.addData(\"Vertical left encoder position\", robot.verticalLeft.getCurrentPosition());\n            telemetry.addData(\"Vertical right encoder position\", robot.verticalRight.getCurrentPosition());\n            telemetry.addData(\"horizontal encoder position\", robot.horizontal.getCurrentPosition());\n\n            telemetry.addData(\"motorRF power\", robot.motorRF.getPower());\n            telemetry.addData(\"motorRB power\", robot.motorRB.getPower());\n            telemetry.addData(\"motorLF power\", robot.motorLF.getPower());\n            telemetry.addData(\"motorLB power\", robot.motorLB.getPower());\n\n            telemetry.update();\n\n\n        }\n\n        turnCorrection(robotPower, robotOrientation, allowableOrientationError);\n\n        setPowerAll(0);\n    }\n\n    public void turnCorrection(double robotPower, double robotOrientation, double allowableOrientationError) {\n\n        RobotHardware robot = new RobotHardware(hardwareMap);\n\n        double pivotCorectionAngle = robotOrientation - globalPositionUpdate.returnOrientation();\n\n        while(opModeIsActive() && Math.abs(pivotCorectionAngle) >= allowableOrientationError)\n        {\n\n            pivotCorectionAngle = robotOrientation - globalPositionUpdate.returnOrientation();\n            double pivotCorectionPower = pivotCorectionAngle / 15;\n\n            //slows down as it nears the target\n            double slowDown;\n\n            if (pivotCorectionAngle >= 5)\n            {\n                slowDown = Math.abs(pivotCorectionPower / 5);\n            } else\n            {\n                slowDown = 1;\n            }\n\n\n            //sets the power of the motors\n            double LFpower = (pivotCorectionPower) /* slowDown */ * robotPower;\n            double LBpower = (pivotCorectionPower) /* slowDown */ * robotPower;\n            double RFpower = (-pivotCorectionPower) /* slowDown */ * robotPower;\n            double RBpower = (-pivotCorectionPower) /* slowDown */ * robotPower;\n\n//if statement reduces/increases motor power accordingly if a motor has more than a power of 1 or less than a power of -1\n//that way all the motors remain proportional but at the highest speed possible forward or reverse\n//if you move slowly there is nothing to reduce and it will still go slowly\n\n            double motorPowerRatio = 1;\n\n            if (LFpower >= 1 && LFpower >= LBpower && LFpower >= RFpower && LFpower >= RBpower)\n            {\n                motorPowerRatio = 1 / LFpower;\n            } else if (LBpower >= 1 && LBpower >= LFpower && LBpower >= RFpower && LBpower >= RBpower)\n            {\n                motorPowerRatio = 1 / LBpower;\n            } else if (RFpower >= 1 && RFpower >= LFpower && RFpower >= LBpower && RFpower >= RBpower)\n            {\n                motorPowerRatio = 1 / RFpower;\n            } else if (RBpower >= 1 && RBpower >= LFpower && RBpower >= RFpower && RBpower >= LBpower)\n            {\n                motorPowerRatio = 1 / RBpower;\n            } else if (LFpower <= -1 && LFpower <= LBpower && LFpower <= RFpower && LFpower <= RBpower)\n            {\n                motorPowerRatio = -1 / LFpower;\n            } else if (LBpower <= -1 && LBpower <= LFpower && LBpower <= RFpower && LBpower <= RBpower)\n            {\n                motorPowerRatio = -1 / LBpower;\n            } else if (RFpower <= -1 && RFpower <= LFpower && RFpower <= LBpower && RFpower <= RBpower)\n            {\n                motorPowerRatio = -1 / RFpower;\n            } else if (RBpower <= -1 && RBpower <= LFpower && RBpower <= RFpower && RBpower <= LBpower)\n            {\n                motorPowerRatio = -1 / RBpower;\n            }\n\n\n//robot power is your speed multiplier\n\n            robot.motorRF.setPower(RFpower * motorPowerRatio);\n            robot.motorRB.setPower(RBpower * motorPowerRatio);\n            robot.motorLB.setPower(LBpower * motorPowerRatio);\n            robot.motorLF.setPower(LFpower * motorPowerRatio);\n\n            telemetry.addData(\"X Position\", globalPositionUpdate.returnXCoordinate() / COUNTS_PER_INCH);\n            telemetry.addData(\"Y Position\", globalPositionUpdate.returnYCoordinate() / COUNTS_PER_INCH);\n            telemetry.addData(\"Orientation (Degrees)\", globalPositionUpdate.returnOrientation());\n\n            telemetry.addData(\"Vertical left encoder position\", robot.verticalLeft.getCurrentPosition());\n            telemetry.addData(\"Vertical right encoder position\", robot.verticalRight.getCurrentPosition());\n            telemetry.addData(\"horizontal encoder position\", robot.horizontal.getCurrentPosition());\n\n            telemetry.addData(\"motorRF power\", robot.motorRF.getPower());\n            telemetry.addData(\"motorRB power\", robot.motorRB.getPower());\n            telemetry.addData(\"motorLF power\", robot.motorLF.getPower());\n            telemetry.addData(\"motorLB power\", robot.motorLB.getPower());\n\n            telemetry.update();\n        }\n    }\n\n    public void setPowerAll(double power)\n    {\n        RobotHardware robot = new RobotHardware(hardwareMap);\n\n        robot.motorRF.setPower(power);\n        robot.motorRB.setPower(power);\n        robot.motorLB.setPower(power);\n        robot.motorLF.setPower(power);\n    }\n    /**\n     * Calculate the power in the x direction\n     * @param desiredAngle angle on the x axis\n     * @param speed robot's speed\n     * @return the x vector\n     */\n    private double calculateX(double desiredAngle, double speed) {\n        return Math.sin(Math.toRadians(desiredAngle)) * speed;\n    }\n\n    /**\n     * Calculate the power in the y direction\n     * @param desiredAngle angle on the y axis\n     * @param speed robot's speed\n     * @return the y vector\n     */\n    private double calculateY(double desiredAngle, double speed) {\n        return Math.cos(Math.toRadians(desiredAngle)) * speed;\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/customOdometryTest.java	(revision f90b0dc05358099e1eb311141f96c8ea64e7fc18)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/customOdometryTest.java	(date 1604164704663)
@@ -5,6 +5,11 @@
 import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
 import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
 import com.qualcomm.robotcore.hardware.DcMotor;
+import com.qualcomm.robotcore.util.ReadWriteFile;
+
+import org.firstinspires.ftc.robotcore.internal.system.AppUtil;
+
+import java.io.File;
 
 @TeleOp(name = "customOdometryTest")
 public class customOdometryTest extends LinearOpMode
@@ -38,17 +43,23 @@
         Thread positionThread = new Thread(globalPositionUpdate);
         positionThread.start();
 
-        goToPosition(100, 0, 1, 0, .5, 1);
-        goToPosition(0, 0, 1, 0, .5, 1);
+        //File wheelBaseSeparationFile = AppUtil.getInstance().getSettingsFile("wheelBaseSeparation.txt");
+      //  File horizontalTickOffsetFile = AppUtil.getInstance().getSettingsFile("horizontalTickOffset.txt");
+
+        //ReadWriteFile.writeFile(wheelBaseSeparationFile, String.valueOf(16.559));
+      //  ReadWriteFile.writeFile(horizontalTickOffsetFile, String.valueOf(6907.26010657654));
+
+        //goToPosition(100, 0, 1, 0, .5, 1);
+        goToPosition(0, 0, 1, 90, .5, 1);
 
         while(opModeIsActive())
         {
 
-            goToPosition(50, 0, 1, 0, .5, 1);
+            //goToPosition(50, 0, 1, 0, .5, 1);
 
-            goToPosition(50, 50, 1, 0, .5, 1);
+            //goToPosition(50, 50, 1, 0, .5, 1);
 
-            goToPosition(0, 0, 1, 0, .5, 1);
+            //goToPosition(0, 0, 1, 0, .5, 1);
 
 //Display Global (x, y, theta) coordinates
             telemetry.addData("X Position", globalPositionUpdate.returnXCoordinate() / COUNTS_PER_INCH);
