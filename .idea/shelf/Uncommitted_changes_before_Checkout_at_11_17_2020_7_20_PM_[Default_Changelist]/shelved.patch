Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/blueAuto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>           package org.firstinspires.ftc.teamcode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\n//other imports\r\n\r\n//genneral\r\n\r\n//odometry\r\n\r\n//tensor flow\r\n\r\n//velocity\r\n\r\n//auto aim\r\n\r\n\r\n\r\n\r\nimport org.firstinspires.ftc.robotcore.external.ClassFactory;\r\nimport org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\r\nimport org.firstinspires.ftc.robotcore.external.tfod.Recognition;\r\nimport org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\r\n\r\nimport java.util.List;\r\n\r\n\r\n@Autonomous(name = \"blueAuto\")\r\npublic class blueAuto extends LinearOpMode {\r\n\r\n  private static final String TFOD_MODEL_ASSET = \"UltimateGoal.tflite\";\r\n  private static final String LABEL_FIRST_ELEMENT = \"Quad\";\r\n  private static final String LABEL_SECOND_ELEMENT = \"Single\";\r\n  public String view = \"\";\r\n  public MecanumDriveTrain drive;\r\n  //init variables\r\n  private static final String VUFORIA_KEY =\r\n          \"AQIjJXP/////AAABmX8DXrmUxEBjvVNbT94EWcg3A75NZTjC3HG9/ur6NlOGrwrPUBWwLK8GlSeDl/fPcBsf+HkwYZQt7Fu8g/fJSvgftOYprWUaAWTCcyEnjfqU7CKCEEeWOO97PEJHdsjSPaRCoKAUjmRCknWJWxPuvgBXU4z63zwtr45AR0DzsF9FRdoj9pNR7hcmPKZmMLSfU6zdeBinzk2DQrJq2GGHJJgI0Mgh/IcrRA54NaGttRaqLpvLOuDHRiPyHnOtOXkjHBZp4Simdyqht675alc36Kyz3PF34/9X6m3b/43kuI231AaSBt1r5GnQv0jL9QRbGde2lr0U8mTmnatRm1ASpgCIcAJJ82jRpyWf3yELRH1w\";\r\n  private VuforiaLocalizer vuforia;\r\n  private TFObjectDetector tfod;\r\n  //genneral\r\n\r\n  //odometry\r\n\r\n  //TFOD\r\n\r\n  //velocity\r\n\r\n  //auto aim\r\n\r\n\r\n  @Override\r\n  public void runOpMode() throws InterruptedException {\r\n    initVuforia();\r\n    initTfod();\r\n    MecanumDriveTrain drive = new MecanumDriveTrain(this);\r\n\r\n    //init\r\n    if (tfod != null) {\r\n      tfod.activate();\r\n\r\n      // The TensorFlow software will scale the input images from the camera to a lower resolution.\r\n      // This can result in lower detection accuracy at longer distances (> 55cm or 22\").\r\n      // If your target is at distance greater than 50 cm (20\") you can adjust the magnification value\r\n      // to artificially zoom in to the center of image.  For best results, the \"aspectRatio\" argument\r\n      // should be set to the value of the images used to create the TensorFlow Object Detection model\r\n      // (typically 1.78 or 16/9).\r\n\r\n      // Uncomment the following line if you want to adjust the magnification and/or the aspect ratio of the input images.\r\n     tfod.setZoom(2, 1.78);\r\n    }\r\n    //genneral\r\n\r\n    //odometry\r\n\r\n    //TFOD\r\n\r\n    //velocity\r\n\r\n    //auto aim\r\n    telemetry.addData(\">\", \"Press Play to start op mode\");\r\n    telemetry.update();\r\n    waitForStart();\r\n\r\n\r\n\r\n\r\n          if (tfod != null) {\r\n            // getUpdatedRecognitions() will return null if no new information is available since\r\n            // the last time that call was made.\r\n            List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\r\n            if (updatedRecognitions != null) {\r\n              telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\r\n              // step through the list of recognitions and display boundary info.\r\n              int i = 0;\r\n              for (Recognition recognition : updatedRecognitions) {\r\n                telemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\r\n                telemetry.addData(String.format(\"  left,top (%d)\", i), \"%.03f , %.03f\",\r\n                        recognition.getLeft(), recognition.getTop());\r\n                telemetry.addData(String.format(\"  right,bottom (%d)\", i), \"%.03f , %.03f\",\r\n                        recognition.getRight(), recognition.getBottom());\r\n                view = recognition.getLabel();\r\n              }\r\n              telemetry.update();\r\n            }\r\n      }\r\n\r\n\r\n\r\n\r\n          drive.timeDrive(100,.5,driveStyle.BACKWARD);\r\n\r\n      if (tfod != null) {\r\n        tfod.shutdown();\r\n      }\r\n\r\n\r\n      sleep(3000);\r\n\r\n     if(view == \"Quad\")\r\n     {\r\n       drive.timeDrive(1000,.5,driveStyle.BACKWARD);\r\n     }\r\n     else if(view == \"Single\")\r\n     {\r\n       drive.timeDrive(1000,.5,driveStyle.FORWARD);\r\n\r\n     }\r\n     else\r\n      {\r\n        drive.timeDrive(1000,.5,driveStyle.STRAFE_LEFT);\r\n\r\n      }\r\n\r\n      //Run Op Mode\r\n\r\n      //see rings with tensor flow\r\n\r\n      //drive up to line and shoot with auto aim\r\n\r\n      //go place wabble goal\r\n\r\n      //drive back and pick up starter stack (if 4 shoot first 1-2 now with auto aim)\r\n\r\n      //pick up other wable goal\r\n\r\n      //grab any remaining rings\r\n\r\n      //drive up to line\r\n\r\n      //shoot remaining rings with auto aim\r\n\r\n      //drop off wable goal\r\n\r\n      //drive to line\r\n    }\r\n\r\n\r\n\r\n\r\n  private void initVuforia() {\r\n    /*\r\n     * Configure Vuforia by creating a Parameter object, and passing it to the Vuforia engine.\r\n     */\r\n    VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();\r\n\r\n    parameters.vuforiaLicenseKey = VUFORIA_KEY;\r\n    parameters.cameraName = hardwareMap.get(WebcamName.class, \"webcam\");\r\n\r\n    //  Instantiate the Vuforia engine\r\n    vuforia = ClassFactory.getInstance().createVuforia(parameters);\r\n\r\n    // Loading trackables is not necessary for the               TensorFlow Object Detection engine.\r\n\r\n  }\r\n\r\n  public void initTfod() {\r\n    int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\r\n            \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\r\n    TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\r\n    tfodParameters.minResultConfidence = 0.6f;\r\n    tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\r\n    tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n  /*\r\n  public voids\r\n  */\r\n  \r\n  //odometry\r\n  \r\n  //TFOD\r\n  \r\n  //Velocity\r\n  \r\n  //auto aim\r\n  \r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/blueAuto.java	(revision 288226bc207fc08dbf9be44ee9f369c459f57eca)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/blueAuto.java	(date 1605236770164)
@@ -120,18 +120,25 @@
 
      if(view == "Quad")
      {
-       drive.timeDrive(1000,.5,driveStyle.BACKWARD);
+       drive.timeDrive(1000,.7,driveStyle.BACKWARD);
      }
      else if(view == "Single")
      {
-       drive.timeDrive(1000,.5,driveStyle.FORWARD);
+       drive.timeDrive(1000,.7,driveStyle.FORWARD);
 
      }
      else
       {
-        drive.timeDrive(1000,.5,driveStyle.STRAFE_LEFT);
+        drive.timeDrive(1000,.7,driveStyle.STRAFE_LEFT);
 
       }
+
+
+     telemetry.addData("next step",0);
+     telemetry.update();
+
+
+     drive.encoderDrive(500,driveStyle.BACKWARD,1);
 
       //Run Op Mode
 
@@ -185,11 +192,10 @@
   }
 
 
-}
+} 
 
 
 
-
   /*
   public voids
   */
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/MecanumDriveTrain.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\r\n\r\nimport com.qualcomm.hardware.bosch.BNO055IMU;\r\nimport com.qualcomm.hardware.bosch.JustLoggingAccelerationIntegrator;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\n\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.Orientation;\r\n\r\npublic class MecanumDriveTrain\r\n{\r\n\r\n    private static final double WHEEL_CIRCUMFERENCE_INCHES = 9.276;\r\n\r\n    private static final int COUNTS_PER_ROTATION = 560;\r\n\r\n    private static final double INCHES_TO_COUNTS = COUNTS_PER_ROTATION / WHEEL_CIRCUMFERENCE_INCHES;\r\n\r\n    public static final double X_DEAD_BAND = 0.1;\r\n    public static final double Y_DEAD_BAND = 0.1;\r\n\r\n    public DcMotor motorRF;\r\n    public DcMotor motorRB;\r\n    public DcMotor motorLF;\r\n    public DcMotor motorLB;\r\n\r\n    public BNO055IMU imu;\r\n\r\n    public LinearOpMode linearOpMode;\r\n\r\n   /*Argument Breakdown:\r\n     dirX - Represents left joystick X value\r\n     dirY - Represents left joystick Y value\r\n     pivot - Represents right joystick X value\r\n    */\r\n\r\n   public MecanumDriveTrain(LinearOpMode linearOpMode)\r\n   {\r\n\r\n       motorRF = linearOpMode.hardwareMap.dcMotor.get(\"motorRF\");\r\n       motorRB = linearOpMode.hardwareMap.dcMotor.get(\"motorRB\");\r\n       motorLF = linearOpMode.hardwareMap.dcMotor.get(\"motorLF\");\r\n       motorLB = linearOpMode.hardwareMap.dcMotor.get(\"motorLB\");\r\n\r\n       this.linearOpMode = linearOpMode;\r\n\r\n       setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n\r\n       // IMU Init\r\n       BNO055IMU.Parameters parametersIMU = new BNO055IMU.Parameters(); //Declares parameters object forIMU\r\n       parametersIMU.angleUnit = BNO055IMU.AngleUnit.DEGREES; //Sets the unit in which we measure orientation in degrees\r\n       parametersIMU.accelUnit = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC; //Sets acceleration unit in meters per second ??\r\n       parametersIMU.calibrationDataFile = \"AdafruitIMUCalibration.json\"; // see the calibration sample opmode, sets what file the IMU ueses\r\n       parametersIMU.loggingEnabled = true; //Sets wether logging in enable\r\n       parametersIMU.loggingTag = \"IMU\"; //Sets logging tag\r\n       parametersIMU.accelerationIntegrationAlgorithm = new JustLoggingAccelerationIntegrator(); //Sets acceleration integration algorithm\r\n       parametersIMU.temperatureUnit = BNO055IMU.TempUnit.CELSIUS; //Sets units for temperature readings\r\n       imu = linearOpMode.hardwareMap.get(BNO055IMU.class, \"imu\"); //Inits IMU\r\n       imu.initialize(parametersIMU); //Init IMU parameters (set above)\r\n\r\n   }\r\n\r\n   private void setZeroPowerBehavior(DcMotor.ZeroPowerBehavior behavior)\r\n   {\r\n       motorRF.setZeroPowerBehavior(behavior);\r\n       motorLF.setZeroPowerBehavior(behavior);\r\n       motorLB.setZeroPowerBehavior(behavior);\r\n       motorRB.setZeroPowerBehavior(behavior);\r\n   }\r\n\r\n   public double[] teleOpDrive(double dirX, double dirY, double pivot)\r\n    {\r\n        // Dead-band for driving straight (accounts for slight movement in the X direction)\r\n        if(dirX >= -X_DEAD_BAND && dirX <= X_DEAD_BAND)\r\n        {\r\n            dirX = 0;\r\n        }\r\n\r\n        // Dead-band for driving straight (accounts for slight movement in the Y direction)\r\n        if(dirY >= -Y_DEAD_BAND && dirY <= Y_DEAD_BAND)\r\n        {\r\n            dirY = 0;\r\n        }\r\n\r\n        //Array is used to store motors so they can be easily accessed in the method call based on the return value\r\n        double[] motorPowers = new double[4];\r\n        motorPowers[0] = -(dirY + dirX) - pivot;//robot.motorRF.setPower(speed*((-gamepad1.left_stick_y - gamepad1.left_stick_x) - (zScale * gamepad1.right_stick_x)));\r\n        motorPowers[1] = (dirX - dirY) - pivot;//robot.motorRB.setPower(speed*(-(-gamepad1.left_stick_x + gamepad1.left_stick_y) - (zScale * gamepad1.right_stick_x)));\r\n        motorPowers[2] = (dirY + dirX) - pivot;//robot.motorLB.setPower(speed*((gamepad1.left_stick_y + gamepad1.left_stick_x) - (zScale * gamepad1.right_stick_x)));\r\n        motorPowers[3] = (-dirX + dirY) - pivot;//robot.motorLF.setPower(speed*((-gamepad1.left_stick_x + gamepad1.left_stick_y)) - (zScale * gamepad1.right_stick_x));\r\n\r\n        //References\r\n            //motorPowers[0] = motorRF\r\n            //motorPowers[1] = motorRB\r\n            //motorPowers[2] = motorLB\r\n            //motorPowers[3] = motorLF\r\n\r\n        // Left side is reversed -1 power = forward\r\n        // Right side 1 power = forward\r\n\r\n        return motorPowers;\r\n    }\r\n\r\n\r\n    //Method that drives the robot via encoder target values and what the current encoder value of the motors are\r\n\r\n    /*\r\n    Argument Breakdown:\r\n    encoderDelta - Desired total change of the starting encoder value. How far the robot will go via encoder count readings\r\n    driveStyle - Desired direction the robot will drive. Uses enumeration declared at the top of the class\r\n    motorPower - Desired motor power the firstMeetMecanum motors will run at\r\n    motors - Array that contains the firstMeetMecanum motors. This is passed in so we can use the motors from an outside class (OpMode) in this class\r\n     */\r\n    public boolean encoderDriveInches(double distanceInches, driveStyle drive, double motorPower)\r\n    {\r\n\r\n\r\n        double encoderDelta = distanceInches * INCHES_TO_COUNTS;\r\n\r\n        //Comments in FORWARD also apply for all the other cases in this method\r\n\r\n        //Switch statement used to handle which driveStyle enumeration was selected\r\n        switch(drive)\r\n        {\r\n            //If desired firstMeetMecanum direction was forward\r\n            case FORWARD:\r\n            {\r\n                //Declares a sets a variable for the starting encoder value on a specific motor\r\n                double encoderReadingLB = motorRB.getCurrentPosition();\r\n                //Calculates desired encoder value by adding/subtracting the reading taken above by the desired encoder delta\r\n                double target = (encoderReadingLB + encoderDelta);\r\n\r\n                //Method declaration that will set the correct motor powers to move the robot the desired direction (based on which case you are in) with desired motor power\r\n                forward(motorPower);\r\n\r\n                /*\r\n                Loop that haults the code from progressing till the desired encoder count is met.\r\n                This desired encoder value could either be positive or negative, so the appropriate logic is applied.\r\n                */\r\n                while (motorRB.getCurrentPosition() <= target)\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n\r\n\r\n            }\r\n\r\n            case BACKWARD:\r\n            {\r\n                double encoderReadingLB = motorRB.getCurrentPosition();\r\n                double target = (encoderReadingLB - encoderDelta);\r\n                backward(motorPower);\r\n\r\n                while (motorRB.getCurrentPosition() >= target)\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n            }\r\n\r\n            case STRAFE_LEFT:\r\n            {\r\n                double encoderReadingLB = motorRB.getCurrentPosition();\r\n                double target = (encoderReadingLB + encoderDelta);\r\n                strafeLeft(motorPower);\r\n\r\n                while (motorRB.getCurrentPosition() <= target)\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n            }\r\n\r\n            case STRAFE_RIGHT:\r\n            {\r\n                double encoderReadingLB = motorRB.getCurrentPosition();\r\n                double target = (encoderReadingLB + encoderDelta);\r\n                strafeRight(motorPower);\r\n\r\n                while (motorRB.getCurrentPosition() <= target)\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n            }\r\n\r\n            case FORWARD_LEFT:\r\n            {\r\n                double encoderReadingLB = motorRB.getCurrentPosition();\r\n                double target = (encoderReadingLB - encoderDelta);\r\n                forwardLeft(motorPower);\r\n                while (motorRB.getCurrentPosition() >= target)\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n            }\r\n\r\n            case FORWARD_RIGHT:\r\n            {\r\n                double encoderReadingRB = motorRF.getCurrentPosition();\r\n                double target = (encoderReadingRB + encoderDelta);\r\n                forwardRight(motorPower);\r\n\r\n                while (motorRF.getCurrentPosition() <= target)\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n            }\r\n\r\n            case BACKWARD_LEFT:\r\n            {\r\n                double encoderReadingRB = motorRF.getCurrentPosition();\r\n                double target = (encoderDelta - encoderReadingRB);\r\n                backwardLeft(motorPower);\r\n\r\n                while (motorRF.getCurrentPosition() >= target)\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n            }\r\n\r\n            case BACKWARD_RIGHT:\r\n            {\r\n                double encoderReadingLB =motorRB.getCurrentPosition();\r\n                double target = (encoderReadingLB + encoderDelta);\r\n                backwardRight(motorPower);\r\n\r\n                while (motorRB.getCurrentPosition() <= target)\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n            }\r\n\r\n            case PIVOT_LEFT:\r\n            {\r\n                double encoderReadingLB = motorRB.getCurrentPosition();\r\n                double target = (encoderReadingLB + encoderDelta);\r\n                pivotLeft(motorPower);\r\n\r\n                while (motorRB.getCurrentPosition() <= target)\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n            }\r\n\r\n            case PIVOT_RIGHT:\r\n            {\r\n                double encoderReadingLB = motorRB.getCurrentPosition();\r\n                double target = (encoderDelta - encoderReadingLB);\r\n                pivotRight(motorPower);\r\n\r\n                while (motorRB.getCurrentPosition() >= target)\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n            }\r\n\r\n\r\n        }\r\n\r\n        //Stops all the motors\r\n        stopMotors();\r\n\r\n       //Return value to see if the method was successfully executed\r\n       return true;\r\n    }\r\n\r\n    public boolean encoderDrive(double encoderDelta, driveStyle drive, double motorPower)\r\n    {\r\n\r\n        //Comments in FORWARD also apply for all the other cases in this method\r\n\r\n        //Switch statement used to handle which driveStyle enumeration was selected\r\n        switch(drive)\r\n        {\r\n            //If desired firstMeetMecanum direction was forward\r\n            case FORWARD:\r\n            {\r\n                //Declares a sets a variable for the starting encoder value on a specific motor\r\n                double encoderReadingLB = motorRB.getCurrentPosition();\r\n                //Calculates desired encoder value by adding/subtracting the reading taken above by the desired encoder delta\r\n                double target = (encoderReadingLB + encoderDelta);\r\n\r\n                //Method declaration that will set the correct motor powers to move the robot the desired direction (based on which case you are in) with desired motor power\r\n                forward(motorPower);\r\n\r\n                /*\r\n                Loop that haults the code from progressing till the desired encoder count is met.\r\n                This desired encoder value could either be positive or negative, so the appropriate logic is applied.\r\n                */\r\n                while (motorRB.getCurrentPosition() <= target && linearOpMode.opModeIsActive())\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n\r\n\r\n            }\r\n\r\n            case BACKWARD:\r\n            {\r\n                double encoderReadingLB = motorRB.getCurrentPosition();\r\n                double target = (encoderReadingLB - encoderDelta);\r\n                backward(motorPower);\r\n\r\n                while (motorRB.getCurrentPosition() >= target && linearOpMode.opModeIsActive())\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n            }\r\n\r\n            case STRAFE_LEFT:\r\n            {\r\n                //double encoderReadingLB = motorRB.getCurrentPosition();\r\n                double target = (motorRB.getCurrentPosition() - encoderDelta);\r\n                strafeLeft(motorPower);\r\n\r\n                while (motorRB.getCurrentPosition() >= target && linearOpMode.opModeIsActive())\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n            }\r\n\r\n            case STRAFE_RIGHT:\r\n            {\r\n                double encoderReadingLB = motorRB.getCurrentPosition();\r\n                double target = (encoderReadingLB + encoderDelta);\r\n                strafeRight(motorPower);\r\n\r\n                while (motorRB.getCurrentPosition() <= target && linearOpMode.opModeIsActive())\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n            }\r\n\r\n            case FORWARD_LEFT:\r\n            {\r\n\r\n                double encoderReadingLB = motorRB.getCurrentPosition();\r\n                double target = (encoderReadingLB - encoderDelta);\r\n                forwardLeft(motorPower);\r\n                while (motorRB.getCurrentPosition() >= target && linearOpMode.opModeIsActive())\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n            }\r\n\r\n            case FORWARD_RIGHT:\r\n            {\r\n                double encoderReadingRB = motorRF.getCurrentPosition();\r\n                double target = (encoderReadingRB + encoderDelta);\r\n                forwardRight(motorPower);\r\n\r\n                while (motorRF.getCurrentPosition() <= target && linearOpMode.opModeIsActive())\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n            }\r\n\r\n            case BACKWARD_LEFT:\r\n            {\r\n                double encoderReadingRB = motorRF.getCurrentPosition();\r\n                double target = (encoderDelta - encoderReadingRB);\r\n                backwardLeft(motorPower);\r\n\r\n                while (motorRF.getCurrentPosition() >= target && linearOpMode.opModeIsActive())\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n            }\r\n\r\n            case BACKWARD_RIGHT:\r\n            {\r\n                double encoderReadingLB =motorRB.getCurrentPosition();\r\n                double target = (encoderReadingLB + encoderDelta);\r\n                backwardRight(motorPower);\r\n\r\n                while (motorRB.getCurrentPosition() <= target && linearOpMode.opModeIsActive())\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n            }\r\n\r\n            case PIVOT_LEFT:\r\n            {\r\n                double encoderReadingLB = motorRB.getCurrentPosition();\r\n                double target = (encoderReadingLB + encoderDelta);\r\n                pivotLeft(motorPower);\r\n\r\n                while (motorRB.getCurrentPosition() <= target && linearOpMode.opModeIsActive())\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n            }\r\n\r\n            case PIVOT_RIGHT:\r\n            {\r\n                double encoderReadingLB = motorRB.getCurrentPosition();\r\n                double target = (encoderDelta - encoderReadingLB);\r\n                pivotRight(motorPower);\r\n\r\n                while (motorRB.getCurrentPosition() >= target && linearOpMode.opModeIsActive())\r\n                {\r\n                    linearOpMode.telemetry.addData(\"Current Position\", motorRB.getCurrentPosition());\r\n                    linearOpMode.telemetry.addData(\"Target Position\", target);\r\n                    linearOpMode.telemetry.update();\r\n                }\r\n                break;\r\n            }\r\n\r\n\r\n        }\r\n\r\n        //Stops all the motors\r\n        stopMotors();\r\n\r\n        //Return value to see if the method was successfully executed\r\n        return true;\r\n    }\r\n\r\n\r\n    public void timeDrive(long time, double motorPower, driveStyle drive)\r\n    {\r\n        switch(drive)\r\n        {\r\n            case FORWARD:\r\n                {\r\n                    forward(motorPower);\r\n\r\n                    linearOpMode.sleep(time);\r\n\r\n                    break;\r\n                }\r\n\r\n            case BACKWARD:\r\n            {\r\n                backward(motorPower);\r\n\r\n                linearOpMode.sleep(time);\r\n\r\n                break;\r\n\r\n            }\r\n\r\n            case STRAFE_LEFT:\r\n            {\r\n                strafeLeft(motorPower);\r\n\r\n                linearOpMode.sleep(time);\r\n\r\n                break;\r\n            }\r\n\r\n            case STRAFE_RIGHT:\r\n            {\r\n                strafeRight(motorPower);\r\n\r\n                linearOpMode.sleep(time);\r\n\r\n                break;\r\n            }\r\n\r\n            case FORWARD_LEFT:\r\n            {\r\n                forwardLeft(motorPower);\r\n\r\n                linearOpMode.sleep(time);\r\n\r\n                break;\r\n            }\r\n\r\n            case FORWARD_RIGHT:\r\n            {\r\n                forwardRight(motorPower);\r\n\r\n\r\n                linearOpMode.sleep(time);\r\n\r\n                break;\r\n            }\r\n\r\n            case BACKWARD_LEFT:\r\n            {\r\n                backwardLeft(motorPower);\r\n\r\n                linearOpMode.sleep(time);\r\n\r\n                break;\r\n            }\r\n\r\n            case BACKWARD_RIGHT:\r\n            {\r\n                backwardRight(motorPower);\r\n\r\n                linearOpMode.sleep(time);\r\n\r\n                break;\r\n            }\r\n\r\n            case PIVOT_LEFT:\r\n            {\r\n                pivotLeft(motorPower);\r\n\r\n\r\n\r\n\r\n                linearOpMode.sleep(time);\r\n\r\n                break;\r\n            }\r\n\r\n            case PIVOT_RIGHT:\r\n            {\r\n                pivotRight(motorPower);\r\n\r\n                linearOpMode.sleep(time);\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n\r\n        //Stops all the motors\r\n        stopMotors();\r\n\r\n    }\r\n    public void OrientationDrive(double TargetOr, double motorPower, BNO055IMU imu) {\r\n        Orientation angles;\r\n        angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n\r\n        double PivotDeg;\r\n        PivotDeg = (TargetOr - AngleUnit.DEGREES.fromUnit(angles.angleUnit, angles.firstAngle));\r\n\r\n        if (PivotDeg > 0)\r\n        {\r\n            pivotLeft(motorPower);\r\n\r\n            while (TargetOr > AngleUnit.DEGREES.fromUnit(angles.angleUnit, angles.firstAngle) && linearOpMode.opModeIsActive())\r\n            {\r\n                angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n                linearOpMode.telemetry.addData(\"Orientation Target\", TargetOr);\r\n                linearOpMode.telemetry.addData(\"Current Orientation\", AngleUnit.DEGREES.fromUnit(angles.angleUnit, angles.firstAngle));\r\n                linearOpMode.telemetry.update();\r\n            }\r\n            //Stops all the motors\r\n            stopMotors();\r\n        }\r\n        else\r\n        {\r\n            pivotRight(motorPower);\r\n\r\n            while (TargetOr < AngleUnit.DEGREES.fromUnit(angles.angleUnit, angles.firstAngle) && linearOpMode.opModeIsActive())\r\n            {\r\n                angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n                linearOpMode.telemetry.addData(\"Orientation Target\", TargetOr);\r\n                linearOpMode.telemetry.addData(\"Current Orientation\", AngleUnit.DEGREES.fromUnit(angles.angleUnit, angles.firstAngle));\r\n                linearOpMode.telemetry.update();\r\n            }\r\n\r\n            //Stops all the motors\r\n            stopMotors();\r\n\r\n        }\r\n    }\r\n\r\n\r\n    private void forward(double motorPower)\r\n    {\r\n        motorRF.setPower(teleOpDrive(0, -motorPower, 0)[0]);\r\n        motorRB.setPower(teleOpDrive(0, -motorPower, 0)[1]);\r\n        motorLB.setPower(teleOpDrive(0, -motorPower, 0)[2]);\r\n        motorLF.setPower(teleOpDrive(0, -motorPower, 0)[3]);\r\n    }\r\n    public void backward(double motorPower)\r\n    {\r\n        motorRF.setPower(teleOpDrive(0, motorPower, 0)[0]);\r\n        motorRB.setPower(teleOpDrive(0, motorPower, 0)[1]);\r\n        motorLB.setPower(teleOpDrive(0, motorPower, 0)[2]);\r\n        motorLF.setPower(teleOpDrive(0, motorPower, 0)[3]);\r\n    }\r\n    private void strafeLeft(double motorPower)\r\n    {\r\n        motorRF.setPower(teleOpDrive(-motorPower, 0, 0)[0]);\r\n        motorRB.setPower(teleOpDrive(-motorPower, 0, 0)[1]);\r\n        motorLB.setPower(teleOpDrive(-motorPower, 0, 0)[2]);\r\n        motorLF.setPower(teleOpDrive(-motorPower, 0, 0)[3]);\r\n    }\r\n    private void strafeRight(double motorPower)\r\n    {\r\n        motorRF.setPower(teleOpDrive(motorPower, 0, 0)[0]);\r\n        motorRB.setPower(teleOpDrive(motorPower, 0, 0)[1]);\r\n        motorLB.setPower(teleOpDrive(motorPower, 0, 0)[2]);\r\n        motorLF.setPower(teleOpDrive(motorPower, 0, 0)[3]);\r\n    }\r\n    private void forwardLeft(double motorPower)\r\n    {\r\n        motorRF.setPower(teleOpDrive(-motorPower, -motorPower, 0)[0]);\r\n        motorRB.setPower(teleOpDrive(-motorPower, -motorPower, 0)[1]);\r\n        motorLB.setPower(teleOpDrive(-motorPower, -motorPower, 0)[2]);\r\n        motorLF.setPower(teleOpDrive(-motorPower, -motorPower, 0)[3]);\r\n    }\r\n    private void forwardRight(double motorPower)\r\n    {\r\n        motorRF.setPower(teleOpDrive(motorPower, -motorPower, 0)[0]);\r\n        motorRB.setPower(teleOpDrive(motorPower, -motorPower, 0)[1]);\r\n        motorLB.setPower(teleOpDrive(motorPower, -motorPower, 0)[2]);\r\n        motorLF.setPower(teleOpDrive(motorPower, -motorPower, 0)[3]);\r\n    }\r\n    private void backwardLeft(double motorPower)\r\n    {\r\n       motorRF.setPower(teleOpDrive(-motorPower, motorPower, 0)[0]);\r\n       motorRB.setPower(teleOpDrive(-motorPower, motorPower, 0)[1]);\r\n       motorLB.setPower(teleOpDrive(-motorPower, motorPower, 0)[2]);\r\n       motorLF.setPower(teleOpDrive(-motorPower, motorPower, 0)[3]);\r\n    }\r\n    private void backwardRight(double motorPower)\r\n    {\r\n       motorRF.setPower(teleOpDrive(motorPower, motorPower, 0)[0]);\r\n       motorRB.setPower(teleOpDrive(motorPower, motorPower, 0)[1]);\r\n       motorLB.setPower(teleOpDrive(motorPower, motorPower, 0)[2]);\r\n       motorLF.setPower(teleOpDrive(motorPower, motorPower, 0)[3]);\r\n    }\r\n    private void pivotLeft(double motorPower)\r\n    {\r\n        motorRF.setPower(teleOpDrive(0, 0, -motorPower)[0]);\r\n        motorRB.setPower(teleOpDrive(0, 0, -motorPower)[1]);\r\n        motorLB.setPower(teleOpDrive(0, 0, -motorPower)[2]);\r\n        motorLF.setPower(teleOpDrive(0, 0, -motorPower)[3]);\r\n\r\n    }\r\n    private void pivotRight(double motorPower)\r\n    {\r\n        motorRF.setPower(teleOpDrive(0, 0, motorPower)[0]);\r\n        motorRB.setPower(teleOpDrive(0, 0, motorPower)[1]);\r\n        motorLB.setPower(teleOpDrive(0, 0, motorPower)[2]);\r\n        motorLF.setPower(teleOpDrive(0, 0, motorPower)[3]);\r\n    }\r\n\r\n    private void stopMotors()\r\n    {\r\n        //Stops all the motors\r\n        motorRF.setPower(teleOpDrive(0, 0, 0)[0]);\r\n        motorRB.setPower(teleOpDrive(0, 0, 0)[1]);\r\n        motorLB.setPower(teleOpDrive(0, 0, 0)[2]);\r\n        motorLF.setPower(teleOpDrive(0, 0, 0)[3]);\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/MecanumDriveTrain.java	(revision 288226bc207fc08dbf9be44ee9f369c459f57eca)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/MecanumDriveTrain.java	(date 1605236085743)
@@ -10,7 +10,7 @@
 import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;
 import org.firstinspires.ftc.robotcore.external.navigation.Orientation;
 
-public class MecanumDriveTrain
+public class                    MecanumDriveTrain
 {
 
     private static final double WHEEL_CIRCUMFERENCE_INCHES = 9.276;
