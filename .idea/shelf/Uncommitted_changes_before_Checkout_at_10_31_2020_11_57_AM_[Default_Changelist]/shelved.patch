Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/customOdometryTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\n\n//import org.firstinspires.ftc.teamcode.OdometryGlobalCoordinatePosition;\n\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\n\n@TeleOp(name = \"customOdometryTest\")\npublic class customOdometryTest extends LinearOpMode\n{\n\n    //encoder counts per in of movement (counts per rotation / pi*r^2\n    final double COUNTS_PER_INCH = 1312.54037886341;\n\n    //OdometryGlobalCoordinatePosition is the thread\n//globalPositionThread is a variable that will hold the thread with specific info like the names of the encoders\n    OdometryGlobalCoordinatePosition globalPositionUpdate;\n\n    @Override\n    public void runOpMode() throws InterruptedException\n    {\n\n//call hardware map\n        RobotHardware robot = new RobotHardware(hardwareMap);\n\n        robot.motorRF.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        robot.motorLF.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        robot.motorRB.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        robot.motorLB.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        telemetry.addData(\"Status\", \"Init Complete\");\n        telemetry.update();\n        waitForStart();\n\n//fills the thread variable with the thread with encoder names how many ticks per in and the delay\n        globalPositionUpdate = new OdometryGlobalCoordinatePosition(robot.verticalLeft, robot.verticalRight, robot.horizontal, COUNTS_PER_INCH, 75);\n        Thread positionThread = new Thread(globalPositionUpdate);\n        positionThread.start();\n\n        goToPosition(100, 0, 1, 0, .5);\n        goToPosition(0, 0, 1, 0, .5);\n\n        while(opModeIsActive())\n        {\n\n            goToPosition(50, 0, 1, 0, .5);\n\n            goToPosition(50, 50, 1, 0, .5);\n\n            goToPosition(0, 0, 1, 0, .5);\n\n//Display Global (x, y, theta) coordinates\n            telemetry.addData(\"X Position\", globalPositionUpdate.returnXCoordinate() / COUNTS_PER_INCH);\n            telemetry.addData(\"Y Position\", globalPositionUpdate.returnYCoordinate() / COUNTS_PER_INCH);\n            telemetry.addData(\"Orientation (Degrees)\", globalPositionUpdate.returnOrientation());\n\n//Display encoder values\n            telemetry.addData(\"Vertical left encoder position\", robot.verticalLeft.getCurrentPosition());\n            telemetry.addData(\"Vertical right encoder position\", robot.verticalRight.getCurrentPosition());\n            telemetry.addData(\"horizontal encoder position\", robot.horizontal.getCurrentPosition());\n\n            telemetry.addData(\"motorRF power\", robot.motorRF.getPower());\n            telemetry.addData(\"motorRB power\", robot.motorRB.getPower());\n            telemetry.addData(\"motorLF power\", robot.motorLF.getPower());\n            telemetry.addData(\"motorLB power\", robot.motorLB.getPower());\n\n            telemetry.addData(\"Thread Active\", positionThread.isAlive());\n            telemetry.update();\n        }\n\n//Stop the thread\n        globalPositionUpdate.stop();\n\n    }\n\n    public void goToPosition(double targetXPosition, double targetYPosition, double robotPower, double robotOrientation, double allowableDistanceError)\n    {\n        RobotHardware robot = new RobotHardware(hardwareMap);\n\n        targetXPosition = targetXPosition * COUNTS_PER_INCH;\n        targetYPosition = targetYPosition * COUNTS_PER_INCH;\n        allowableDistanceError = allowableDistanceError * COUNTS_PER_INCH;\n\n        double distanceToXTarget = targetXPosition - globalPositionUpdate.returnXCoordinate();\n        double distanceToYTarget = targetYPosition - globalPositionUpdate.returnYCoordinate();\n\n        double distance = Math.hypot(distanceToXTarget, distanceToYTarget);\n\n        while(opModeIsActive() &&  distance > allowableDistanceError)\n        {\n            distance = Math.hypot(distanceToXTarget, distanceToYTarget);\n\n            distanceToXTarget = targetXPosition - globalPositionUpdate.returnXCoordinate();\n            distanceToYTarget = targetYPosition - globalPositionUpdate.returnYCoordinate();\n\n            double robotMovementAngle = Math.toDegrees(Math.atan2(distanceToXTarget, distanceToYTarget));\n\n            double robotMovementXComponent = calculateX(robotMovementAngle, robotPower);\n            double robotMovementYComponent = calculateY(robotMovementAngle, robotPower);\n\n            double pivotCorectionAngle = robotOrientation - globalPositionUpdate.returnOrientation();\n            double pivotCorectionPower = pivotCorectionAngle / 180;\n\n            //slows down as it nears the target\n            double slowDown;\n\n            if (distance / COUNTS_PER_INCH <= 3)\n            {\n                slowDown = Math.abs(distance / COUNTS_PER_INCH / 3);\n            }\n\n            else\n            {\n                slowDown = 1;\n            }\n\n\n            //sets the power of the motors\n            double LFpower = (robotMovementXComponent + robotMovementYComponent + pivotCorectionPower) * slowDown * robotPower;\n            double LBpower = (robotMovementXComponent - robotMovementYComponent + pivotCorectionPower) * slowDown * robotPower;\n            double RFpower = (robotMovementXComponent - robotMovementYComponent - pivotCorectionPower) * slowDown * robotPower;\n            double RBpower = (robotMovementXComponent + robotMovementYComponent - pivotCorectionPower) * slowDown * robotPower;\n\n//if statement reduces/increases motor power accordingly if a motor has more than a power of 1 or less than a power of -1\n//that way all the motors remain proportional but at the highest speed possible forward or reverse\n//if you move slowly there is nothing to reduce and it will still go slowly\n\n            double motorPowerRatio = 1;\n\n            if (LFpower >= 1 && LFpower >= LBpower && LFpower >= RFpower && LFpower >= RBpower)\n            {\n                motorPowerRatio = 1 / LFpower;\n            } else if (LBpower >= 1 && LBpower >= LFpower && LBpower >= RFpower && LBpower >= RBpower)\n            {\n                motorPowerRatio = 1 / LBpower;\n            } else if (RFpower >= 1 && RFpower >= LFpower && RFpower >= LBpower && RFpower >= RBpower)\n            {\n                motorPowerRatio = 1 / RFpower;\n            } else if (RBpower >= 1 && RBpower >= LFpower && RBpower >= RFpower && RBpower >= LBpower)\n            {\n                motorPowerRatio = 1 / RBpower;\n            } else if (LFpower <= -1 && LFpower <= LBpower && LFpower <= RFpower && LFpower <= RBpower)\n            {\n                motorPowerRatio = -1 / LFpower;\n            } else if (LBpower <= -1 && LBpower <= LFpower && LBpower <= RFpower && LBpower <= RBpower)\n            {\n                motorPowerRatio = -1 / LBpower;\n            } else if (RFpower <= -1 && RFpower <= LFpower && RFpower <= LBpower && RFpower <= RBpower)\n            {\n                motorPowerRatio = -1 / RFpower;\n            } else if (RBpower <= -1 && RBpower <= LFpower && RBpower <= RFpower && RBpower <= LBpower)\n            {\n                motorPowerRatio = -1 / RBpower;\n            }\n\n\n\n//robot power is your speed multiplier\n\n            robot.motorRF.setPower(RFpower * motorPowerRatio);\n            robot.motorRB.setPower(RBpower * motorPowerRatio);\n            robot.motorLB.setPower(LBpower * motorPowerRatio);\n            robot.motorLF.setPower(LFpower * motorPowerRatio);\n\n            telemetry.addData(\"X Position\", globalPositionUpdate.returnXCoordinate() / COUNTS_PER_INCH);\n            telemetry.addData(\"Y Position\", globalPositionUpdate.returnYCoordinate() / COUNTS_PER_INCH);\n            telemetry.addData(\"Orientation (Degrees)\", globalPositionUpdate.returnOrientation());\n\n            telemetry.addData(\"Vertical left encoder position\", robot.verticalLeft.getCurrentPosition());\n            telemetry.addData(\"Vertical right encoder position\", robot.verticalRight.getCurrentPosition());\n            telemetry.addData(\"horizontal encoder position\", robot.horizontal.getCurrentPosition());\n\n            telemetry.addData(\"motorRF power\", robot.motorRF.getPower());\n            telemetry.addData(\"motorRB power\", robot.motorRB.getPower());\n            telemetry.addData(\"motorLF power\", robot.motorLF.getPower());\n            telemetry.addData(\"motorLB power\", robot.motorLB.getPower());\n\n            telemetry.update();\n\n\n        }\n\n        setPowerAll(0);\n    }\n\n    public void setPowerAll(double power)\n    {\n        RobotHardware robot = new RobotHardware(hardwareMap);\n\n        robot.motorRF.setPower(power);\n        robot.motorRB.setPower(power);\n        robot.motorLB.setPower(power);\n        robot.motorLF.setPower(power);\n    }\n    /**\n     * Calculate the power in the x direction\n     * @param desiredAngle angle on the x axis\n     * @param speed robot's speed\n     * @return the x vector\n     */\n    private double calculateX(double desiredAngle, double speed) {\n        return Math.sin(Math.toRadians(desiredAngle)) * speed;\n    }\n\n    /**\n     * Calculate the power in the y direction\n     * @param desiredAngle angle on the y axis\n     * @param speed robot's speed\n     * @return the y vector\n     */\n    private double calculateY(double desiredAngle, double speed) {\n        return Math.cos(Math.toRadians(desiredAngle)) * speed;\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/customOdometryTest.java	(revision e6bb7c79ea675bea3a7900a33703200a70bb152a)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/customOdometryTest.java	(date 1604162615422)
@@ -5,6 +5,11 @@
 import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
 import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
 import com.qualcomm.robotcore.hardware.DcMotor;
+import com.qualcomm.robotcore.util.ReadWriteFile;
+
+import org.firstinspires.ftc.robotcore.internal.system.AppUtil;
+
+import java.io.File;
 
 @TeleOp(name = "customOdometryTest")
 public class customOdometryTest extends LinearOpMode
@@ -37,6 +42,10 @@
         globalPositionUpdate = new OdometryGlobalCoordinatePosition(robot.verticalLeft, robot.verticalRight, robot.horizontal, COUNTS_PER_INCH, 75);
         Thread positionThread = new Thread(globalPositionUpdate);
         positionThread.start();
+        File wheelBaseSeparationFile = AppUtil.getInstance().getSettingsFile("wheelBaseSeparation.txt");
+        File horizontalTickOffsetFile = AppUtil.getInstance().getSettingsFile("horizontalTickOffset.txt");
+        ReadWriteFile.writeFile(wheelBaseSeparationFile, String.valueOf(16.559));
+        ReadWriteFile.writeFile(horizontalTickOffsetFile, String.valueOf(-3000));
 
         goToPosition(100, 0, 1, 0, .5);
         goToPosition(0, 0, 1, 0, .5);
@@ -44,6 +53,7 @@
         while(opModeIsActive())
         {
 
+
             goToPosition(50, 0, 1, 0, .5);
 
             goToPosition(50, 50, 1, 0, .5);
